<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<title>正则表达式匹配N的倍数</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="正则表达式匹配N的倍数" />
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<link rel="alternate" type="application/rss+xml" title="I'm Jex" href="../rss.xml"/>
<link rel="shortcut icon" href="../favicon.png" type="image/png" />
</head>
<body>
  <nav class="category-path">
   <a href="../index.html" rel="home">Home</a> »
    
    <a href="../programming/index.html" rel="category">Programming</a> »
    
    <em>正则表达式匹配N的倍数</em>
</nav>

  <h1 class="article-title">
    <a href="./triple-regex.html" rel="self" class="normal">正则表达式匹配N的倍数</a>
  </h1>
  <div class="title-info">
    <small><a href="https://jex.im/" rel="author" class="normal">Jex</a> — <time>2014-08-15</time></small>
  </div>


  
  <article  id="main">
    <p><a href="http://regex.alf.nu/9" target="_blank">Regex Golf</a>上有一道题名为 Triples，即要求用正则表达式匹配3的倍数，还有一道匹配7的倍数的练习题。这种问题如果人肉解决的话，相当于做一道包含几十个数的四则运算题，不管你怎么想，反正我小时候遇到五个数以上的四则运算题都是直接略过。小时候不好好学习，现在该怎么办呢？——现在我会写代码了啊。
解决方案其实很简单：写程序构造一个接受3的倍数的<a href="https://zh.wikipedia.org/zh/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank">DFA</a>，再将其转换成正则式即可。</p>

<h2>Finite Automaton</h2>
<p>术语听起来都好抽象，其实解决思路就像小学生做除法一样简单。比如我们如何判定<code>4641</code>是3的倍数？
从左往右一个数一个数地计算，最后余0即可：</p>
<pre style="display:table;min-width:20em;margin:0 auto;">
4641
4    % 3 =&gt; 1
16   % 3 =&gt; 1
 14  % 3 =&gt; 2
  21 % 3 =&gt; 0
</pre>
<p>一次读一个数字，然后输出一个余数，如果最后余0则表示OK。影响我们判断的有两个因素：上次运算结果的余数，当前读入的字符。自动机就是这样一种机器，开始处于一个状态，每次读入一个字符，然后输出一个新状态。所以上面的运算可以用下面的自动机执行过程表示，起始状态为0，余数即为输出状态：</p>
<table class="plain">
  <tr>
    <td>
<pre>
  4
0 =&gt; 1
</pre>
    </td>
    <td>
<pre>
  6
1 =&gt; 1
</pre>
    </td>
    <td>
<pre>
  4
1 =&gt; 2
</pre>
    </td>
    <td>
<pre>
  1
2 =&gt; 0
</pre>
    </td>
  </tr>
</table>

<p>用人话来讲就是：上次余数为0时，遇到4则余1；上次余1时遇到6则还余1；……<br/>
数字只有10个，所以我们可以穷举，除3余数只有0、1、2三种可能，当余数为任意一个时，下一次遇到的数字只有10种可能，
全部情况列举成一张表：</p>
<table style="text-align:center">
  <thead>
    <tr>
    <td>上次余数（From State）</td>
    <td>遇到数字（Input Char）</td>
    <td>输出余数（To State）</td>
    </tr>
  </thead>
  <tr><td rowspan="3">0</td><td>0、3、6、9</td><td>0</td></tr>
  <tr><td>1、4、7</td><td>1</td></tr>
  <tr><td>2、5、8</td><td>2</td></tr>
  <tr><td rowspan="3">1</td><td>0、3、6、9</td><td>1</td></tr>
  <tr><td>1、4、7</td><td>2</td></tr>
  <tr><td>2、5、8</td><td>0</td></tr>
  <tr><td rowspan="3">2</td><td>0、3、6、9</td><td>2</td></tr>
  <tr><td>1、4、7</td><td>0</td></tr>
  <tr><td>2、5、8</td><td>1</td>
  </tr>
</table>

<p>教科书都喜欢画DFA流程图，我也用<a href="http://www.graphviz.org/" target="_blank">GraphViz</a>将就画个（这么乱的图真能帮助理解吗）：</p>
<p class="text-center">
  <a href="../img/TripleDFA.gv" target="_blank"><img src="../img/TripleDFA.png" alt="Triple DFA Diagram" /></a>
</p>
<p>接下来其实就可以动手写程序自动生成这张表了：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">自动构造接受N的倍数的DFA</span>
<span class="cm">@return { fromState =&gt; { Char =&gt; toState } }</span>
<span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">buildDFA</span><span class="p">(</span><span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">map</span><span class="o">=</span><span class="p">{},</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">to</span><span class="p">;</span>
  <span class="c1">// i 为 From State</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">N</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//FromState不会超过N，因为余数肯定小于N嘛</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// j 为枚举Input Digit Char</span>
      <span class="c1">//当上次余i这次碰到j时，除N的余数即为输出状态</span>
      <span class="nx">to</span><span class="o">=</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">%</span> <span class="nx">N</span><span class="p">;</span>
      <span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">||</span><span class="p">{})[</span><span class="nx">j</span><span class="p">]</span><span class="o">=</span><span class="nx">to</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="nx">map</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这代码也太简单了，用JavaScript写的好处就是现在按下<code>F12</code>将代码贴进去运行下就能看到结果了。可生成这张表有什么用呢？再写个执行DFA的函数就大功告成了：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">运行DFA</span>
<span class="cm">@param {DFA}    a 就是buildDFA返回的表</span>
<span class="cm">@param {String} s 输入数字串</span>
<span class="cm">@return 如果输入匹配则返回true</span>
<span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">runDFA</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nx">from</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nx">l</span><span class="o">=</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">l</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">from</span><span class="o">=</span><span class="nx">a</span><span class="p">[</span><span class="nx">from</span><span class="p">][</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span><span class="c1">//获取到下一个状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">from</span><span class="o">===</span><span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">from</span><span class="o">===</span><span class="mi">0</span><span class="p">;</span><span class="c1">//最后余0则OK</span>
<span class="p">}</span>
<span class="c1">//测试是否是3的倍数</span>
<span class="nx">runDFA</span><span class="p">(</span><span class="nx">buildDFA</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="o">+</span><span class="mi">4614</span><span class="p">);</span>
</pre></div></div>
<p>至此已经做到了生成及执行匹配任意整数倍数的DFA，注意是任意位数的N及其倍数哦。接下来的工作就是将自动机转换成正则表达式。有很多种算法，这里只介绍最易于理解的解方程法。</p>

<h2>Arden's Lemma</h2>
<p>这种方法就是将自动机中的状态变换看成方程组，然后用解方程的方式化简自动机，逐步消减状态，最后合并成一个正则式。该方法基于<a href="https://en.wikipedia.org/wiki/Arden%27s_Rule" target="_blank">Arden's Lemma</a>：</p>
<div style="text-align:center;border-radius:8px;background:white;color:black;" class="math">
L = UL ∪ V ⟺ L = U ∗ V
</div>
<p>看上去好抽象，其实只是Minify过了而已。其中的道理很简单，先看下面的DFA如何转换成正则式：</p>
<table class="plain">
  <tr>
    <td>
<pre>
  a
0 =&gt; 0
</pre>
    </td>
    <td>
<pre>
  b
0 =&gt; 1
</pre>
    </td>
  </tr>
</table>

<p>其中0、1为状态，a、b表示Char，0为起始状态，1为接受状态。这个只包含两条变换的自动机对应于正则式：<code>a*b</code>，这就是<em>Arden's Lemma</em>表达的意思。单这一条引理其实还不够，我们还需要了解正则式其它几个基础性质。我们把这正则式整体当成一个自动机的话，它就是<code>0 =&gt; 1</code>这样一个变换。
正则式的串联，比如<code>a*bc*d</code>，对应于自动机的串联：</p>
<table class="plain">
  <tr>
    <td>
<pre>
  a
0 =&gt; 0
</pre>
    </td>
    <td>
<pre>
  b
0 =&gt; 1
</pre>
    </td>
    <td>
<pre>
  c
1 =&gt; 1
</pre>
    </td>
    <td>
<pre>
  d
1 =&gt; 2
</pre>
    </td>
  </tr>
</table>

<p>其中2为接受状态。那么两个正则式的串联，则可以看成将整体串联成 <code>0 =&gt; 1 =&gt; 2</code>得到<code>0 =&gt; 2</code>。
依此类推，正则式的并联，如<code>(a|b)c</code>，对应于自动机的并联：</p>
<table class="plain">
  <tr>
    <td>
<pre>
  a
0 =&gt; 1
</pre>
    </td>
    <td rowspan="2">
<pre>
  c
1 =&gt; 2
</pre>
    </td>
  </tr>
  <tr>
    <td>
<pre>
  b
0 =&gt; 1
</pre>
    </td>
  </tr>
</table>
<p>好了，其实正则表达式与自动机相互转换的方法就这些。应用到前面的Triple DFA，比如<code>0 =&gt; 0</code>的变换有四条，所以正则式为<code>(0|3|6|9)*</code>，当然更简单的写法是<code>[0369]*</code>，前面<code>buildDFA</code>函数生成的表虽易于执行，但却不便于转换到正则式，所以写一个直接输出如下格式的函数更方便：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;0&quot;</span><span class="p">:{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span><span class="s2">&quot;[0369]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="s2">&quot;[147]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="s2">&quot;[258]&quot;</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>改写后的<code>buildTable</code>函数（其中<code>reflect</code>表后面再解释）：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">buildTable</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">map</span><span class="o">=</span><span class="p">{},</span><span class="nx">reflect</span><span class="o">=</span><span class="p">{},</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">to</span><span class="p">,</span><span class="nx">path</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">path</span><span class="o">=</span><span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">to</span><span class="o">=</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="mi">10</span><span class="o">+</span><span class="nx">j</span><span class="p">)</span> <span class="o">%</span> <span class="nx">n</span><span class="p">;</span>
      <span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
      <span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">+=</span><span class="nx">j</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">to</span><span class="o">&gt;</span><span class="nx">i</span><span class="p">)</span>
        <span class="p">(</span><span class="nx">reflect</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nx">reflect</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="o">||</span> <span class="p">{})[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">to</span> <span class="k">in</span> <span class="nx">path</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;]&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">to</span> <span class="k">in</span> <span class="nx">reflect</span><span class="p">)</span>
    <span class="nx">reflect</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">reflect</span><span class="p">[</span><span class="nx">to</span><span class="p">]);</span>
  <span class="k">return</span> <span class="p">{</span><span class="nx">map</span><span class="o">:</span><span class="nx">map</span><span class="p">,</span><span class="nx">reflect</span><span class="o">:</span><span class="nx">reflect</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>

<p>我们的目标是转换成的正则式只匹配除3余0的数，最终生成的正则式只能是一个<code>0 =&gt; 0</code>的变换，这样才能保证成功匹配时的结束状态一定是0。所以只需要把所有可能的<code>0 =&gt; …… =&gt; 0</code>不重复的变换路径进行并联，就能得到最终的正则式。
比如将<code>0 =&gt; 1 =&gt; 0</code>和<code>0 =&gt; 0</code>并联得到正则式：<code>([0369]|[147][258])*</code>，依此类推。应用前面的<em>Arden's Lemma</em>及其它几条方法，将所有的变换都化简成一条<code>0 =&gt; 0</code>变换，这个过程就像在解一个方程，将不可接受状态当成未知量化解成用0这个可接受状态表示。例如对于TripleDFA，约去状态2的步骤如下所示：</p>
<table>
  <tr>
    <th>Origin</th>
    <th>应用<em>Arden's Lemma</em></th>
  </tr>
  <tr>
    <td>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;2&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[147]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[258]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </td>
    <td>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;2&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]*[147]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]*[258]&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </td>
  </tr>
</table>
<p>然后再将状态1输出中的状态2替换掉，其它依此类推：</p>
<table>
  <tr>
    <th>Origin</th>
    <td>
<div class="highlight"><pre><span></span><span class="p">{</span>
 <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[258]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;[147]&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </td>
  </tr>
  <tr>
    <th><code>1 =&gt; 2 => X</code>串联</th>
    <td>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[258]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[147][0369]*[147]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[147][0369]*[258]&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </td>
  </tr>
  <tr>
    <th><code>1 =&gt; X</code>并联</th>
    <td>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;0&quot;</span><span class="p">:</span> <span class="s2">&quot;[258]|[147][0369]*[147]&quot;</span><span class="p">,</span>
    <span class="nt">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;[0369]|[147][0369]*[258]&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </td>
  </tr>
</table>
<p>前面<code>buildTable</code>中的<code>reflect</code>表就是用于反查哪些状态可以到达当前要约去的状态，以便将其替换掉。</p>

<p>在化简过程中，无非对正则式进行串联、并联、重复这三种操作，相应的处理函数如下：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="c1">// seq([&quot;[147]&quot;,&quot;[258]&quot;]) =&gt; &quot;[147][258]&quot;</span>
<span class="kd">function</span> <span class="nx">seq</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span><span class="s1">&#39;seq&#39;</span><span class="p">,</span>
    <span class="nx">toString</span><span class="o">:</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">re</span><span class="o">=</span><span class="nx">a</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">)</span>
        <span class="nx">re</span><span class="o">=</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">?</span><span class="s1">&#39;(&#39;</span><span class="o">+</span><span class="nx">re</span><span class="o">+</span><span class="s1">&#39;)*&#39;</span><span class="o">:</span><span class="nx">re</span><span class="o">+</span><span class="s1">&#39;*&#39;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">re</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// choice([&quot;[147]&quot;,&quot;[258]&quot;]) =&gt; &quot;[147]|[258]&quot;</span>
<span class="kd">function</span> <span class="nx">choice</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">items</span><span class="o">=</span><span class="p">[];</span>
  <span class="c1">//这一步其实只是为了使生成的正则式更短一些</span>
  <span class="c1">//按并联的结合性，&quot;a|(b|c)&quot; 等同于 &quot;a|b|c&quot;</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">re</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">type</span><span class="o">===</span><span class="s1">&#39;choice&#39;</span><span class="p">)</span>
      <span class="nx">items</span><span class="o">=</span><span class="nx">items</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">re</span><span class="p">.</span><span class="nx">items</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">re</span><span class="p">)</span>
      <span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">re</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span><span class="s1">&#39;choice&#39;</span><span class="p">,</span> <span class="nx">items</span><span class="o">:</span><span class="nx">items</span><span class="p">,</span>
    <span class="nx">toString</span><span class="o">:</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">re</span><span class="o">=</span><span class="nx">items</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">)</span> <span class="nx">re</span><span class="o">=</span><span class="s1">&#39;(&#39;</span><span class="o">+</span><span class="nx">re</span><span class="o">+</span><span class="s1">&#39;)&#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">repeat</span><span class="p">)</span> <span class="nx">re</span><span class="o">+=</span><span class="s1">&#39;*&#39;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">re</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// 将一个正则式标志为重复</span>
<span class="kd">function</span> <span class="nx">repeat</span><span class="p">(</span><span class="nx">re</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">re</span><span class="o">===</span><span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="nx">re</span><span class="o">+</span><span class="s1">&#39;*&#39;</span><span class="p">;</span>
  <span class="nx">re</span><span class="p">.</span><span class="nx">repeat</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">re</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>除去拼接正则式的代码，最终的函数也不算长：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">buildRegex</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">table</span><span class="o">=</span><span class="nx">buildTable</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span><span class="nx">i</span><span class="o">=</span><span class="nx">n</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">to</span><span class="p">,</span><span class="nx">path</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">map</span><span class="o">=</span><span class="nx">table</span><span class="p">.</span><span class="nx">map</span><span class="p">,</span><span class="nx">reflect</span><span class="o">=</span><span class="nx">table</span><span class="p">.</span><span class="nx">reflect</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">trans</span><span class="o">=</span><span class="nx">map</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">t</span><span class="o">=</span><span class="p">{},</span>
        <span class="nx">prefix</span><span class="o">=</span><span class="nx">trans</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">?</span><span class="nx">repeat</span><span class="p">(</span><span class="nx">trans</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">:</span><span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">to</span> <span class="k">in</span> <span class="nx">trans</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">to</span><span class="o">&lt;</span><span class="nx">i</span><span class="p">)</span> <span class="nx">t</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nx">trans</span><span class="p">[</span><span class="nx">to</span><span class="p">];</span>

    <span class="nx">trans</span><span class="o">=</span><span class="nx">t</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="nx">to</span> <span class="k">in</span> <span class="nx">trans</span><span class="p">)</span>
      <span class="nx">trans</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nx">seq</span><span class="p">([</span><span class="nx">prefix</span><span class="p">,</span><span class="nx">trans</span><span class="p">[</span><span class="nx">to</span><span class="p">]]);</span>

    <span class="kd">var</span> <span class="nx">entrances</span><span class="o">=</span><span class="nx">reflect</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="nx">j</span><span class="o">=</span><span class="nx">entrances</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">j</span><span class="o">--</span><span class="p">;)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">from</span><span class="o">=</span><span class="nx">entrances</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
      <span class="nx">path</span><span class="o">=</span><span class="nx">map</span><span class="p">[</span><span class="nx">from</span><span class="p">];</span>
      <span class="nx">prefix</span><span class="o">=</span><span class="nx">path</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="nx">to</span> <span class="k">in</span> <span class="nx">trans</span><span class="p">)</span>
        <span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span><span class="o">=</span><span class="nx">choice</span><span class="p">([</span><span class="nx">path</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">,</span><span class="nx">seq</span><span class="p">([</span><span class="nx">prefix</span><span class="p">,</span><span class="nx">trans</span><span class="p">[</span><span class="nx">to</span><span class="p">]])]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="nx">repeat</span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;$&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>

<p>执行<code>buildRegex(3)</code>生成的正则表达式如下，<a href="http://regex.alf.nu/9" target="_blank">Regex Golf</a>评分 523 Points：</p>
<pre>^([0369]|[258][0369]*[147]|([147]|[258][0369]*[258])([0369]|[147][0369]*[258])*([258]|[147][0369]*[147]))*$</pre>

<p>这个函数生成出的匹配7的倍数的正则式有近16K，虽然说它能生成匹配任意位整数倍数的正则式，但这并不现实，因为它生成的正则式体积呈指数级增涨，生成20以上的正则式内存就不够用了。而这么长的正则式让JS的正则引擎去解析的话，大约15以上就会报错。如果去执行匹配测试的话，大于13就有可能返回 False，这是因为执行时间过长，正则引擎就会放弃执行。优化当然还是可以做的，比如生成的正则式输出时使用非捕获分组如<code>(:?[147])</code>，执行速度则可以提升好几倍。</p>

<p>我知道很多人会说用正则式匹配3的倍数效率太低了，有什么必要呢？我当然知道没人真的会这么用正则式，<strong>但这道理还是需要讲明白的</strong>。姑且不谈使用<code>atoi</code>的方法即使在64位机上也只能处理长度不超过二十位的数字，试问这个正则表达式真的很慢吗？这可不一定。正则引擎其实还是将正则式转换成DFA或NFA执行的，如果是编译到DFA，虽然编译会花费些时间和内存，但执行速度只慢在额外的内存读取，DFA复杂度和<code>atoi</code>函数一样都是<span class="math">Θ(n)</span>，即使慢也只是常数倍。如果直接执行原始DFA，理论上可以和<code>atoi</code>函数一样快，这道理是明摆着的。
你不信的话，用下面的C++程序测试看，即使<a href="https://code.google.com/p/re2" target="_blank">re2</a>也只不过慢了5倍而已：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;re2/re2.h&gt;</span><span class="cp"></span>
<span class="cp">#define LOOP_TIMES 10000000</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">dfa</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
    <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
  <span class="kt">clock_t</span> <span class="n">start</span><span class="p">;</span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">num</span><span class="o">=</span><span class="s">&quot;2147483646&quot;</span><span class="p">;</span>

  <span class="n">i</span><span class="o">=</span><span class="n">LOOP_TIMES</span><span class="p">;</span>
  <span class="n">start</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="o">=</span><span class="n">num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">from</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span> <span class="o">*</span><span class="n">str</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">from</span><span class="o">=</span><span class="n">dfa</span><span class="p">[</span><span class="n">from</span><span class="p">][(</span><span class="o">*</span><span class="n">str</span><span class="o">++</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">)];</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">isTriple</span><span class="o">=</span><span class="n">from</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot; DFA:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>

  <span class="n">i</span><span class="o">=</span><span class="n">LOOP_TIMES</span><span class="p">;</span>
  <span class="n">start</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">isTriple</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;atoi:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>

  <span class="n">RE2</span><span class="o">::</span><span class="n">Options</span> <span class="n">opt</span><span class="p">(</span><span class="n">RE2</span><span class="o">::</span><span class="n">Latin1</span><span class="p">);</span>
  <span class="n">opt</span><span class="p">.</span><span class="n">set_never_capture</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">RE2</span> <span class="n">re</span><span class="p">(</span><span class="s">&quot;(?:[0369]|[258][0369]*[147]|&quot;</span>
  <span class="s">&quot;(?:[147]|[258][0369]*[258])&quot;</span>
  <span class="s">&quot;(?:[0369]|[147][0369]*[258])*&quot;</span>
  <span class="s">&quot;(?:[258]|[147][0369]*[147]))*&quot;</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

  <span class="n">i</span><span class="o">=</span><span class="n">LOOP_TIMES</span><span class="p">;</span>
  <span class="n">start</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">isTriple</span> <span class="o">=</span><span class="n">RE2</span><span class="o">::</span><span class="n">FullMatch</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">re</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot; re2:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>

<p>如果你仍然觉得正则表达式肯定很慢的话，那看下面的JavaScript测试程序：</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">LOOP_TIMES</span><span class="o">=</span><span class="mi">10000000</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">re</span><span class="o">=</span><span class="sr">/^(?:[0369]|[258][0369]*[147]|(?:[147]|[258][0369]*[258])(?:[0369]|[147][0369]*[258])*(?:[258]|[147][0369]*[147]))*$/</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">s</span><span class="o">=</span><span class="s2">&quot;31457283145728&quot;</span><span class="p">,</span>
    <span class="nx">i</span><span class="p">,</span><span class="nx">isTriple</span><span class="p">,</span><span class="nx">start</span><span class="p">;</span>
<span class="nx">start</span><span class="o">=+</span><span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
<span class="nx">i</span><span class="o">=</span><span class="nx">LOOP_TIMES</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="nx">isTriple</span><span class="o">=</span><span class="nx">re</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;  RegExp:&quot;</span><span class="p">,(</span><span class="o">+</span><span class="k">new</span> <span class="nb">Date</span><span class="p">)</span><span class="o">-</span><span class="nx">start</span><span class="p">);</span>

<span class="nx">start</span><span class="o">=+</span><span class="k">new</span> <span class="nb">Date</span><span class="p">;</span>
<span class="nx">i</span><span class="o">=</span><span class="nx">LOOP_TIMES</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="nx">isTriple</span><span class="o">=</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;parseInt:&quot;</span><span class="p">,(</span><span class="o">+</span><span class="k">new</span> <span class="nb">Date</span><span class="p">)</span><span class="o">-</span><span class="nx">start</span><span class="p">);</span>
</pre></div>

<p>运行结果显示<code>parseInt</code>方式更慢！为什么？呵呵，因为JS中 Number 是双精度64位浮点数，如果将上面C++程序中<code>atoi</code>改成<code>atof</code>、使用<code>fmod</code>取余的话，运行结果显示取余比正则式只快了不到一倍！</p>
<p>好了，现在至少没人再拿这正则表达式效率低说事了吧。</p>
    
  </article>
  <hr />
  
    <nav class="near-posts link-list">
    
            <a href="./python-free-list-glimpse.html" rel="next"><i>⇦</i><em>Python FreeList内存重用机制一瞥</em></a>
        
        
            <a href="./instruction-align-perf.html" rel="prev" class="prev"><i>⇨</i><em>指令对齐性能影响初探</em></a>
        
    </nav>
    <hr />
  

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = "jexim";
        var disqus_config = function () {
          this.page.url = "https://jex.im/./triple-regex.html";
          this.page.identifier = "programming/triple-regex";
          this.page.category_id = "programming";
          this.page.title = "正则表达式匹配N的倍数";
        };

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  


<!-- Build: 2019-07-14 13:22:43 +0800 -->
  <footer class="site-footer">
      <a rel="license"
      title="This blog is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License."
      href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank"><!--img alt="知识共享许可协议" src="https://i.creativecommons.org/l/by-sa/3.0/80x15.png" width="80" height="14" /--><img width="80" height="15" title="知识共享许可协议" alt="知识共享许可协议" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAIAAAD8q9/YAAAABGdBTUEAANbY1E9YMgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIySURBVHjaYmAYYYARiP///z9SfMvIyAJhrdm0Glliz669M6fO7OjoKC8vx9Tm6up66tSptu5WcQlxIFdeVsHVyfXjh4+D3LeQeGXClHj54uXyxctx+RYIdu/ebWZmNrl/CoT74eOHwoLCoRLJWDy8fMkKYWFhXL6FAGBw3Lxxc8PajUD2x08fPHw8vH28h6qHL128lJ6eDmScPXtWWVkZmO6Bafj9+/dAEsgGigDFjY2NXVxcrl29BjWFiQnIRUs/EICcnDDZ+LXQonBhwvDt5c+fPgP9A2SHhYUBGUBbgWRnZyfQn+/evQPG/L1794CyQME7t+/AUzUwkWOWEEAAcTScASSBbKy+ZYQBZC7V/Yzu4a9fvgBJQUFBYJQCPQbxOTABA9lKSkpA8bS0tNDQUFgRD3X6z58/GFkYscYY3HsQ18O5aPEJkUVLCPSIYW4eHiAJ9C3Qb0AfAmMVUiwDuUA/A8UrKipmzZqFljjZ2Tn+//mPJ4ax1hDw+MSqHk2WVh7W09fl5eWF+BMYsXv27AHaCvQ5kA2MbSEhIaAIJLueOXNGUVkRokuAXwBYUeGPYYJ1BknqKW14INfDfV39z58+v3//Ph5twBAxMTGJjosOCPYHcmWl5Zobmrdu2TrI62FgaGIppaPjot6+fQOMUjyay8rKVFSVIb7l5xPYsWXHIPctvmoJ2H5KzUytrKxsb2/HqsfJ2en69esFJQXw9Nw/oX+0LT1I29IjrbPEABBgAEdwNeO7yfOaAAAAAElFTkSuQmCC" /></a>
      <small>
        Powered by <a href="https://jex.im/PlainSite/" target="_blank">PlainSite</a>.
      </small>
  </footer>
</body>
</html>