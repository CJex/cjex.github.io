<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<title>Python FreeList内存重用机制一瞥</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Python FreeList内存重用机制一瞥" />
<link rel="stylesheet" type="text/css" href="../css/style.css" />
<link rel="alternate" type="application/rss+xml" title="I'm Jex" href="../rss.xml"/>
<link rel="shortcut icon" href="../favicon.png" type="image/png" />
</head>
<body>
  <nav class="category-path">
   <a href="../index.html" rel="home">Home</a> »
    
    <a href="../programming/index.html" rel="category">Programming</a> »
    
    <em>Python FreeList内存重用机制一瞥</em>
</nav>

  <h1 class="article-title">
    <a href="./python-free-list-glimpse.html" rel="self" class="normal">Python FreeList内存重用机制一瞥</a>
  </h1>
  <div class="title-info">
    <small><a href="https://jex.im/" rel="author" class="normal">Jex</a> — <time>2014-09-14</time></small>
  </div>


  
  <article  id="main">
    <p>一次被人问起为什么下面这段Python代码两次调用返回的List对象id相同：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[]):</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">foo</span><span class="p">([]))</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">foo</span><span class="p">([]))</span>
</pre></div></div>
<p>这很简单，只要认真读文档就会明白，因为<a href="https://docs.python.org/2/library/functions.html#id" target="_blank">Python中id方法</a>的返回值，只保证在该对象存活期内是唯一的，两个存活期不同的对象可能会有相同的id：</p>
<blockquote>
<h6>id(object)</h6>
<div style="padding-left:2em">Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. <b style="color:navy">Two objects with non-overlapping lifetimes may have the same id() value.</b>
</div>
<div style="padding-left:2em;"><b>CPython implementation detail: </b>This is the address of the object in memory.
</div>
</blockquote>
<p>比如<code class="highlight"><span class="k">print</span> <span class="nb">id</span><span class="p">([])</span><span class="o">==</span><span class="nb">id</span><span class="p">([])</span></code>，其执行过程是先创建一个临时List #1，获取它的地址，然后List #1被Free，随后再创建新的List #2时，则有可能重用刚才被释放的List #1的内存，所以地址就有可能相同。</p>
<p>不过随后又有一个新问题，为什么<code class="highlight"><span class="nb">id</span><span class="p">([])</span><span class="o">==</span><span class="nb">id</span><span class="p">([])</span></code>始终为True？这也很简单，CPython中List、Tuple、Int等类型，内部实现其实都有一个<code>free_list</code>，当一个对象被销毁时，它的内存并不会被立即回收，而是放到这个池中，当下次再创建新的对象时，则重用上次被销毁对象的内存。从下面的代码可以推测出这个缓冲池的工作方式，按照对象创建销毁的先后次序不同，新的对象会领取到不同的地址：</p>
<div class="center">
<div class="highlight"><pre><span></span><span class="n">a</span><span class="o">=</span><span class="p">[];</span> <span class="n">b</span><span class="o">=</span><span class="p">[];</span>
<span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 这样肯定是 False 啦</span>

<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
  <span class="n">a</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">执行一次 id(f1()) 大致过程为（假设free_list不为空）：</span>
<span class="sd">a=free_list.pop(); _tmp=id(a);</span>
<span class="sd">free_list.append(a); del a</span>
<span class="sd">每次都领到相同的free_list[-1]</span>
<span class="sd">所以始终为True</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">f1</span><span class="p">())</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">f1</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span>
  <span class="n">b</span><span class="o">=</span><span class="p">[];</span> <span class="n">a</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">执行 id(f2())的大致过程为</span>
<span class="sd">b=free_list.pop()</span>
<span class="sd">a=free_list.pop()</span>
<span class="sd">因为b在函数退出后即被销毁，所以先执行</span>
<span class="sd">free_list.append(b); del b;</span>
<span class="sd">_tmp=id(a)</span>
<span class="sd">free_list.append(a); del a;</span>
<span class="sd">因为 append与pop操作不对称，</span>
<span class="sd">所以始终为False</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">f2</span><span class="p">())</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">f2</span><span class="p">())</span>

<span class="c1"># 并且可以推断出下面的调用始终为True</span>
<span class="n">i</span><span class="o">=</span><span class="nb">id</span><span class="p">(</span><span class="n">f2</span><span class="p">())</span> <span class="p">;</span> <span class="n">f2</span><span class="p">();</span>
<span class="k">print</span> <span class="n">i</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="n">f2</span><span class="p">())</span>
</pre></div>
</div>

<p>可还有一个问题，为什么<code class="highlight"><span class="nb">id</span><span class="p">(</span><span class="nb">list</span><span class="p">())</span><span class="o">==</span><span class="nb">id</span><span class="p">(</span><span class="nb">list</span><span class="p">())</span></code>却为False呢？这还真没注意过，原来<code>list()</code>和ListLiteral内存分配的方法并不一样。先看看<code>free_list</code>实现在哪，见<a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c" target="_blank">listobject.c</a>：</p>
<div class="center">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>94
95
96
97
98
99</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/* Empty list reuse scheme to save calls to malloc and free */</span>
<span class="cp">#ifndef PyList_MAXFREELIST</span>
<span class="cp">#define PyList_MAXFREELIST 80</span>
<span class="cp">#endif</span>
<span class="hll"><span class="k">static</span> <span class="n">PyListObject</span> <span class="o">*</span><span class="n">free_list</span><span class="p">[</span><span class="n">PyList_MAXFREELIST</span><span class="p">];</span>
</span><span class="k">static</span> <span class="kt">int</span> <span class="n">numfree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div>
<p>上面是<code>free_list</code>的声明，可见缓冲池的最大长度只有80，下面是创建List方法<code>PyList_New</code>：</p>
<div class="center">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyList_New</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">;</span>
<span class="cp">#ifdef SHOW_ALLOC_COUNT</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">initialized</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_AtExit</span><span class="p">(</span><span class="n">show_alloc</span><span class="p">);</span>
        <span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Call PyList_New</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="cm">/* Check for overflow without an actual overflow,</span>
<span class="cm">     *  which can cause compiler to optimise out */</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PY_SIZE_MAX</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
    <span class="n">nbytes</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*如果缓冲池中有可用元素*/</span>
</span><span class="hll">        <span class="n">numfree</span><span class="o">--</span><span class="p">;</span>
</span><span class="hll">        <span class="n">op</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">numfree</span><span class="p">];</span> <span class="cm">/* free_list.pop() */</span>
</span>        <span class="n">_Py_NewReference</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">);</span>
<span class="cp">#ifdef SHOW_ALLOC_COUNT</span>
        <span class="n">count_reuse</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="cm">/*free_list中没有可用元素则新建*/</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef SHOW_ALLOC_COUNT</span>
        <span class="n">count_alloc</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Why? */</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="p">)</span> <span class="n">PyMem_MALLOC</span><span class="p">(</span><span class="n">nbytes</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">allocated</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>
<p>与之对应的则是List对象回收<code>list_dealloc</code>方法，需将对象放到<code>free_list</code>中以备后用：</p>


<div class="center">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">list_dealloc</span><span class="p">(</span><span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="n">Py_TRASHCAN_SAFE_BEGIN</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Do it backwards, for Christian Tismer.</span>
<span class="cm">           There&#39;s a simple test case where somehow this reduces</span>
<span class="cm">           thrashing when a *very* large list is created and</span>
<span class="cm">           immediately deleted. */</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">PyMem_FREE</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">);</span><span class="cm">/*虽然Free了内容但未设置成NULL，不知为何*/</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numfree</span> <span class="o">&lt;</span> <span class="n">PyList_MAXFREELIST</span> <span class="o">&amp;&amp;</span> <span class="n">PyList_CheckExact</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
<span class="hll">        <span class="n">free_list</span><span class="p">[</span><span class="n">numfree</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span> <span class="cm">/* free_list.append(op) */</span>
</span>    <span class="k">else</span>
        <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">);</span>
    <span class="n">Py_TRASHCAN_SAFE_END</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
</div>

<p>这些就是<code>free_list</code>的实现源码，不单List类型，其它的Tuple、Set、Int等内建类型都有类似的实现。接着再看<code>list()</code>与<code>[]</code>两种形式Python解释器具体如何解释。直接看反编译得到的ByteCode：</p>

<table>
  <tr>
    <th>Python代码</th>
    <th>反编译输出</th>
  </tr>
  <tr>
    <td>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dis</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
  <span class="n">a</span><span class="o">=</span><span class="p">[]</span>
  <span class="n">b</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
<span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
    </td>
    <td>
<pre>
 0 BUILD_LIST               0
 3 STORE_FAST               0 (a)

 6 LOAD_GLOBAL              0 (list)
 9 CALL_FUNCTION            0
12 STORE_FAST               1 (b)
15 LOAD_CONST               0 (None)
18 RETURN_VALUE
</pre>
    </td>
  </tr>
</table>
<p>也没什么奇怪的东西，一个是执行<code>BUILD_LIST</code>指令，一个是调用函数。再看看<code>BUILD_LIST</code>指令的具体是如何实现的，见<a href="http://svn.python.org/projects/python/trunk/Python/ceval.c" target="_blank">ceval.c</a>，可以看到它直接调用了<code>PyList_New</code>函数，所以它会用到<code>free_list</code>：</p>
<div class="center">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>2202
2203
2204
2205
2206
2207
2208
2209
2210
2211
2212</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">case</span> <span class="n">BUILD_LIST</span><span class="p">:</span>
<span class="hll">  <span class="n">x</span> <span class="o">=</span>  <span class="n">PyList_New</span><span class="p">(</span><span class="n">oparg</span><span class="p">);</span>
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="o">--</span><span class="n">oparg</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
      <span class="n">w</span> <span class="o">=</span> <span class="n">POP</span><span class="p">();</span>
      <span class="n">PyList_SET_ITEM</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">oparg</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">break</span><span class="p">;</span>
</pre></div>
</td></tr></table>
</div>
<p>而<code>list()</code>则是直接调用类型构造方法，对应于<a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c" target="_blank">listobject.c</a>中<code>PyList_Type</code>结构：</p>


<div class="center">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>2767
2768
2769
2770
2771
2772
2773
2774
2775
2776
2777
2778</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">PyTypeObject</span> <span class="n">PyList_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;list&quot;</span><span class="p">,</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">),</span>
    <span class="mi">0</span><span class="p">,</span>
<span class="hll">    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">list_dealloc</span><span class="p">,</span>                   <span class="cm">/* tp_dealloc */</span>
</span>    <span class="cm">/*  ............  */</span>
    <span class="p">(</span><span class="n">initproc</span><span class="p">)</span><span class="n">list_init</span><span class="p">,</span>                        <span class="cm">/* tp_init */</span>
    <span class="n">PyType_GenericAlloc</span><span class="p">,</span>                        <span class="cm">/* tp_alloc */</span>
<span class="hll">    <span class="n">PyType_GenericNew</span><span class="p">,</span>                          <span class="cm">/* tp_new */</span>
</span>    <span class="n">PyObject_GC_Del</span><span class="p">,</span>                            <span class="cm">/* tp_free */</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>
</div>
<p>其中<code>tp_new</code>字段就是该类型的New方法，可以看到List类型只用了<code>PyType_GenericNew</code>函数，该方法并不会使用<code>free_list</code>，但是List类型的析构方法依然是<code>list_dealloc</code>，所以<code class="highlight"><span class="nb">id</span><span class="p">(</span><span class="nb">list</span><span class="p">())</span><span class="o">==</span><span class="nb">id</span><span class="p">([])</span></code>仍然为True。为什么List类型默认的New方法不使用缓冲池呢？我也不太明白。也许是因为按照标准文档中指示的原则，Mutable类型的<a href="https://docs.python.org/2/c-api/typeobj.html#c.PyTypeObject.tp_new" target="_blank">tp_new</a>方法不应作过多的初始化操作：</p>
<blockquote>
<h6><a href="https://docs.python.org/2/c-api/typeobj.html#c.PyTypeObject.tp_new" target="_blank">PyTypeObject.tp_new</a></h6>
A good rule of thumb is that for immutable types, all initialization should take place in tp_new, while for mutable types, most initialization should be deferred to tp_init.
</blockquote>
<p>类似的dict类型也是如此，而int、set、tuple这些Immutable类型则两种创建方式都会使用<code>free_list</code>。</p>
    
  </article>
  <hr />
  
    <nav class="near-posts link-list">
    
        
            <a href="./triple-regex.html" rel="prev" class="prev"><i>⇨</i><em>正则表达式匹配N的倍数</em></a>
        
    </nav>
    <hr />
  

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = "jexim";
        var disqus_config = function () {
          this.page.url = "https://jex.im/./python-free-list-glimpse.html";
          this.page.identifier = "programming/python-free-list-glimpse";
          this.page.category_id = "programming";
          this.page.title = "Python FreeList内存重用机制一瞥";
        };

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  


<!-- Build: 2019-07-14 13:22:43 +0800 -->
  <footer class="site-footer">
      <a rel="license"
      title="This blog is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License."
      href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank"><!--img alt="知识共享许可协议" src="https://i.creativecommons.org/l/by-sa/3.0/80x15.png" width="80" height="14" /--><img width="80" height="15" title="知识共享许可协议" alt="知识共享许可协议" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAIAAAD8q9/YAAAABGdBTUEAANbY1E9YMgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIySURBVHjaYmAYYYARiP///z9SfMvIyAJhrdm0Glliz669M6fO7OjoKC8vx9Tm6up66tSptu5WcQlxIFdeVsHVyfXjh4+D3LeQeGXClHj54uXyxctx+RYIdu/ebWZmNrl/CoT74eOHwoLCoRLJWDy8fMkKYWFhXL6FAGBw3Lxxc8PajUD2x08fPHw8vH28h6qHL128lJ6eDmScPXtWWVkZmO6Bafj9+/dAEsgGigDFjY2NXVxcrl29BjWFiQnIRUs/EICcnDDZ+LXQonBhwvDt5c+fPgP9A2SHhYUBGUBbgWRnZyfQn+/evQPG/L1794CyQME7t+/AUzUwkWOWEEAAcTScASSBbKy+ZYQBZC7V/Yzu4a9fvgBJQUFBYJQCPQbxOTABA9lKSkpA8bS0tNDQUFgRD3X6z58/GFkYscYY3HsQ18O5aPEJkUVLCPSIYW4eHiAJ9C3Qb0AfAmMVUiwDuUA/A8UrKipmzZqFljjZ2Tn+//mPJ4ax1hDw+MSqHk2WVh7W09fl5eWF+BMYsXv27AHaCvQ5kA2MbSEhIaAIJLueOXNGUVkRokuAXwBYUeGPYYJ1BknqKW14INfDfV39z58+v3//Ph5twBAxMTGJjosOCPYHcmWl5Zobmrdu2TrI62FgaGIppaPjot6+fQOMUjyay8rKVFSVIb7l5xPYsWXHIPctvmoJ2H5KzUytrKxsb2/HqsfJ2en69esFJQXw9Nw/oX+0LT1I29IjrbPEABBgAEdwNeO7yfOaAAAAAElFTkSuQmCC" /></a>
      <small>
        Powered by <a href="https://jex.im/PlainSite/" target="_blank">PlainSite</a>.
      </small>
  </footer>
</body>
</html>