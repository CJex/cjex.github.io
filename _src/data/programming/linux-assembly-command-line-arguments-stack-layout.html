---
title: Linux命令行参数在栈中的分配
tags: [Linux,Assembly]
date: 2012-12-25
updated_date: 2013-10-01
---

<p>
  <cite>《Professional Assembly Language — Richard&bull;Blum》</cite>一书第11章<cite>Using Command-Line Parameters</cite>一节讲到，
  32位Linux环境下<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank">ELF</a>
  程序被加载之后，分配的虚拟内存起始字节地址为<code>0x08048000</code>，结束字节地址为<code>0xbfffffff</code>，如下所示：</p>

<table border="1" style="text-align:center;">
  <caption>Program Virtual Memory Area</caption>
  <tr>
    <td><code>0xbfffffff</code></td><td>Stack Data</td>
  </tr>
  <tr>
    <td colspan="2">……</td>
  </tr>
  <tr>
    <td><code>0x08048000</code></td><td>Program Code and Data</td>
  </tr>
</table>

<p>预期Stack Pointer（<code>%esp</code>）初始值也应该是<code>0xbfffffff</code>，但由于Linux会在程序初始化前，将一些诸如命令行参数及环境变量等信息放到栈上，所以（可能从下往上看更易读些）：</p>

<table border="1" class="text-center">
  <caption>Program Stack</caption>
  <tr>
    <td><code>0xc0000000</code>：栈底</td>
  </tr>
  <tr>
    <td><code>0xbffffffc</code>：NULL（0x00000000）</td>
  </tr>
  <tr>
    <td>程序名称字符串值 *</td>
  </tr>
  <tr>
    <td>环境变量字符串值 *</td>
  </tr>
  <tr>
    <td>命令行参数字符串值 *</td>
  </tr>
  <tr>
    <td><a href="http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-IA64/LSB-Core-IA64/processinitialization.html#AUXILIARYVECTOR" target="_blank">ELF Auxiliary Vectors</a></td>
  </tr>
  <tr>
    <td>NULL（结束envp[]）</td>
  </tr>
  <tr>
    <td>环境变量字符串地址列表（envp[]）</td>
  </tr>
  <tr>
    <td>NULL（结束argv[]）</td>
  </tr>
  <tr>
    <td>命令行参数字符串地址列表（argv[]）</td>
  </tr>
  <tr>
    <td><code>%esp</code>：命令行参数个数（dword argc）</td>
  </tr>
</table>
<p class="text-center"><small>* 指多个<code>asciz</code>类型的字符串</small></p>

<p><small>ELF Auxiliary Vectors不是程序所要关心的，可以打开<code>/usr/include/elf.h</code>查看<code>struct Elf32_auxv_t</code>的定义。通过设置环境变量：<code>LD_SHOW_AUXV=1</code>，可以在执行程序前输出AUXV值。</small></p>

<p>按上图所示，下面的代码应该能够毫无悬念地输出命令行参数及环境变量：</p>
<highlight gas>
# File:args.s
# Print command line arguments and environment variables
.section .data
  argcs:.asciz "argc=%d\n"
  argvs:.asciz "argv[%d]=%s\n"
  env_header:.asciz "Environment variables:\n"
  envs:.asciz "%s\n"
.section .text
.global _start
_start:
  movl %esp,%ebp
  pushl (%ebp)
  pushl $argcs
  call printf # Print argc
  addl $8,%esp
  # Print argv[]
  movl $0,%eax
  addl $4,%ebp
argvloop:
  movl (%ebp,%eax,4),%ecx
  jecxz argvloop_end # NULL ends argv[]
  pushl %ecx # String addr
  pushl %eax
  pushl $argvs
  call printf
  # printf ret value override eax,restore from stack
  movl 4(%esp),%eax
  addl $12,%esp
  inc %eax
jmp argvloop
argvloop_end:
  leal 4(%ebp,%eax,4),%ebp # skip argv[] and NULL
  pushl $env_header
  call printf
  addl $4,%esp
envloop:
  movl (%ebp),%ecx
  jecxz end # NULL ends envp[]
  pushl %ecx
  pushl $envs
  call printf
  addl $8,%esp
  addl $4,%ebp
jmp envloop
end:
  pushl $0
  call exit
</highlight>
<p>但要注意编译方式，因为使用了C的<code>printf</code>函数，所以需要链接libc：</p>
<pre class="terminal">
$ as --gstabs args.s -o args.o
$ ld args-libc.o -o args.bin  --dynamic-linker /lib/ld-linux.so.2 -lc
$ ./args.bin
</pre>

<p>很明显，用<abbr title="GNU Assembler">GAS</abbr>编译很麻烦，用<a href="http://gcc.gnu.org/" target="_blank" title="GCC, the GNU Compiler Collection">GCC</a>则方便很多，只需要一条命令就可以了：<code>gcc -o args.bin args.s</code>，GCC会一步做好编译链接工作。不过GCC和GAS有一个区别，GAS将<code>_start</code>视作<em>程序执行起点</em>，而GCC则将main当作<em>执行起点</em>。如果要使用GCC编译，则需要将<code>.global _start</code>改成<code>.global main</code>：</p>
<highlight gas>
# hello.s
# 使用GCC的Hello,world汇编程序示例
.section .data
  msg:.asciz "Hello,world!\n"
.section .text
.global main
main:
  push $msg
  call printf
  push $0
  call exit
</highlight>


<p><cite>《Professional Assembly Language》</cite>第四章<cite>Creating a Simple Program - Assembling using a compiler</cite>一节中介绍了这种方式，不过书中并没有就这种差别再作深层解释，给读者留了一个大坑。为什么说是大坑呢？其实，GCC所指定的main，文中所说的<em>Beginning of the program
</em>，并不是真正的Entry Point。如果只是Entry Point名称的区别的话，你会立即查找到<code>ld</code>命令有一个<code>-e</code>参数可用于指定Entry Point名称：</p>
<blockquote>
-e entry<br />
--entry=entry<br />
<p style="padding-left:2em">
Use entry as the explicit symbol for beginning execution of your program, rather than the default entry point.
If there is no symbol named entry, the linker will try to parse entry as a number, and use that as the entry
address (the number will be interpreted in base 10; you may use a leading 0x for base 16, or a leading 0 for
base 8).
</p>
</blockquote>
<p>事实上main并不是Entry Point名称！使用GCC编译，GCC会自己添加上libc的<code>_start</code>作为entry point，然后再在执行时调用main。将上面的代码编译一下： <code>gcc -o hello.bin hello.s  -gstabs</code>（参数<code>-gstabs</code>是为了生成可用于<a href="https://www.gnu.org/software/gdb/" target="_blank">GDB</a>调试的信息）。可以通过<code>readelf</code>命令查看ELF Header：</p>
<pre class="terminal">
$ readelf -h hello.bin|grep Entry
  <i style="color:orange;">Entry point address:               0x8048360</i>
</pre>
<p>地址<code>0x8048360</code>才是它的入口地址。通过GDB来验证一下：</p>
<pre class="terminal">
$ gdb -q hello.bin
Reading symbols from ./hello.bin...done.
(gdb) disassemble _start
Dump of assembler code for function <i style="color:orange;">_start</i>:
   <i style="color:orange;">0x08048360</i> &lt;+0&gt;:     xor    %ebp,%ebp
   0x08048362 &lt;+2&gt;:     pop    %esi
   0x08048363 &lt;+3&gt;:     mov    %esp,%ecx
   0x08048365 &lt;+5&gt;:     and    $0xfffffff0,%esp
   0x08048368 &lt;+8&gt;:     push   %eax
   0x08048369 &lt;+9&gt;:     push   %esp
   0x0804836a &lt;+10&gt;:    push   %edx
   0x0804836b &lt;+11&gt;:    push   $0x80484a0
   0x08048370 &lt;+16&gt;:    push   $0x8048430
   0x08048375 &lt;+21&gt;:    push   %ecx
   0x08048376 &lt;+22&gt;:    push   %esi
   0x08048377 &lt;+23&gt;:    push   <i style="color:#F40;">$0x8048414</i>
   0x0804837c &lt;+28&gt;:    call   0x8048350 &lt;__libc_start_main@plt&gt;
(gdb) disassemble main
Dump of assembler code for function <i style="color:#F40;">main</i>:
   <i style="color:#F40;">$0x8048414</i> &lt;+0&gt;:     push   $0x804a018
   0x08048419 &lt;+5&gt;:     call   0x8048320 &lt;printf@plt&gt;
   0x0804841e &lt;+10&gt;:    push   $0x0
   0x08048420 &lt;+12&gt;:    call   0x8048340 &lt;exit@plt&gt;
(gdb)
</pre>

<p>可以看到，<code>main</code>部分确实是我们写的代码，但程序执行，却是从<code>_start</code>开始的。GCC加载的libc中的_start代码，会将main的地址作为参数（<code>push   $0x8048414</code>）传给<code>__libc_start_main</code>，<code>__libc_start_main</code>执行作了很多准备操作后再去调用<code>main</code>。这会带来什么问题呢？事实上，如果我们将上面的<code>args.s</code>的_start改成main，然后用GCC编译的话，就会取不到正确的命令行参数。看到main这个名称，我们一定会联想到C语言的main函数，事实上这两者几乎是等价的，可以通过查看<code>main.c</code>生成的汇编代码验证这点：</p>
<highlight c>
#include <stdio.h>
int main(int argc,char *argv[],char *envp[]) {
  printf("Hello,world!\n");
}
</highlight>
<p>执行<code>gcc -S main.c</code>以生成<code>main.s</code>文件：</p>
<highlight gas>
  .file "main.c"
  .section  .rodata
.LC0:
  .string "Hello,world!"
  .text
  .globl  main
  .type main, @function
main:
.LFB0:
  .cfi_startproc
  pushl   %ebp
  .cfi_def_cfa_offset 8
  .cfi_offset 5, -8
  movl    %esp, %ebp
# 省略部分内容
</highlight>
<p>可以看到，C中的main函数也是被转换成Assembly中的<code>.global main</code>，那么看一下C中main函数的声明：<highlight c>int main(int argc,char *argv[],char *envp[]);</highlight>，就会明白，最终在调用main时，栈中已经变成这样了：</p>

<table border="1" class="text-center">
  <caption>main执行时栈中的情况</caption>
  <tr>
    <td><code>%esp+12</code>：环境变量字符串数组的指针（*envp[]）</td>
  </tr>
  <tr>
    <td><code>%esp+8</code>：命令行参数字符串数组的指针（*argv[]）</td>
  </tr>
  <tr>
    <td><code>%esp+4</code>：命令行参数个数（argc）</td>
  </tr>
  <tr>
    <td><code>%esp</code>：main返回地址 <br /><small>* 注意，栈顶第一个元素不是argc而是main返回地址。<br/>因为main也是通过call指令调用，而call指令会将返回地址push进栈！</small></td>
  </tr>
</table>


<p>再通过GDB验证一下：<br/><small>* 注意是从汇编代码编译，而不是直接从C代码编译。因为从C代码编译，生成的调试信息中main标签的地址，是main函数第一行代码的地址，通过gdb调试时，<code>break main</code>将在main的第一行代码处停止，而在这之前，已经运行过了<code>push   %ebp</code>、<code>sub    $0x64,%esp</code>（在栈上分配局部变量空间）这些<a href="https://en.wikipedia.org/wiki/Function_prologue" target="_blank">Function Prologue</a>指令了，所以此时栈的结构会受main函数的局部变量大小及其它因素的影响。</small></p>
<pre class="terminal">
$ gcc hello.s -o hello.bin -gstabs
$ gdb -q hello.bin
Reading symbols from ./hello.bin...done.
(gdb) break main
Breakpoint 1 at <i style="color:fuchsia">0x8048414</i>: file hello.s, line 8.
(gdb) run 1 2 3
Starting program: ./hello.bin 1 2 3

Breakpoint 1, main () at hello.s:8
8         push $hello
(gdb) x/4wx $esp <i style="color:gray"># 依次为：返回地址，argc,*argv[],*envp[]</i>
0xbffff17c:     <i style="color:red;">0x001704d3</i>      <i style="color:#0FF">0x00000004</i>      <i style="color:#66F">0xbffff214</i>      <i style="color:#FF0;">0xbffff228</i>
(gdb) x/4wx <i style="color:#66F">0xbffff214</i>  <i style="color:gray"># View argv[]，<i style="color:#0FF">4</i>个命令行参数</i>
0xbffff214:     0xbffff435      <i style="color:#F90">0xbffff45a</i>      0xbffff45c      0xbffff45e
(gdb) x/s <i style="color:#F90">0xbffff45a</i>    <i style="color:gray"># 第二个命令行参数，第一个是程序名称</i>
0xbffff45a:      "1"
(gdb) x/2wx <i style="color:#FF0;">0xbffff228</i> <i style="color:gray"># View envp[]</i>
0xbffff228:     <i style="color:silver">0xbffff460</i>      0xbffff475
(gdb) x/s <i style="color:silver">0xbffff460</i>  <i style="color:gray"># 第一个环境变量值</i>
0xbffff460:      "LC_PAPER=zh_CN.UTF-8"
<i style="color:gray">查看一下main函数返回地址<i style="color:red;">0x001704d3</i>前后的代码</i>
(gdb) disassemble <i style="color:red;">0x001704d3</i>-16,+20
Dump of assembler code from 0x1704c3 to 0x1704d3:
   0x001704c3 &lt;__libc_start_main+227&gt;:  add    $0x89,%al
   0x001704c5 &lt;__libc_start_main+229&gt;:  inc    %esp
   0x001704c6 &lt;__libc_start_main+230&gt;:  and    $0x8,%al
   0x001704c8 &lt;__libc_start_main+232&gt;:  mov    0x74(%esp),%eax
   0x001704cc &lt;__libc_start_main+236&gt;:  mov    %eax,(%esp)
   <i style="color:gray">这一行调用main，main的地址放在0x70(%esp)中</i>
   <i style="color:orange">0x001704cf &lt;__libc_start_main+239&gt;:  call   *0x70(%esp)</i>
   <i style="color:red;">0x001704d3</i> &lt;__libc_start_main+243&gt;:  mov    %eax,(%esp)
   0x001704d6 &lt;__libc_start_main+246&gt;:  call   0x189fb0 <__GI_exit>
<i style="color:gray">查看 0x70(%esp) 单元的值</i>
(gdb) x/1wx $esp+4+0x70  <i style="color:gray">  # call指令push了返回地址，所以到main执行时，这里要再加4</i>
0xbffff1f0:     <i style="color:fuchsia">0x8048414</i>  <i style="color:gray"># 正是main的地址</i>
</pre>


<p>所以上面获取命令行参数的汇编代码，若想用GCC编译还能正确运行，则需要改成这样：</p>
<highlight gas>
.section .data
  argcs:.asciz "argc=%d\n"
  argvs:.asciz "argv[%d]=%s\n"
  env_header:.asciz "Current environment variables:\n"
  envs:.asciz "%s\n"
.section .text
.global main
main:
  movl %esp,%ebp
  pushl 4(%ebp) # Skip ret addr
  pushl $argcs
  call printf # Print argc
  addl $8,%esp
  # Print argv[]
  movl $0,%eax
  movl 8(%esp),%ebp # Skip argc and ret addr
argvloop:
  movl (%ebp,%eax,4),%ecx
  jecxz argvloop_end # NULL ends argv[]
  pushl %ecx # String addr
  pushl %eax
  pushl $argvs
  call printf
  # prinf ret value override eax,restore from stack
  movl 4(%esp),%eax
  addl $12,%esp
  inc %eax
jmp argvloop
argvloop_end:
  movl 12(%esp),%ebp # Skip argc,ret,argv
  pushl $env_header
  call printf
  addl $4,%esp
envloop:
  movl (%ebp),%ecx
  jecxz end # NULL ends envp[]
  pushl %ecx
  pushl $envs
  call printf
  addl $8,%esp
  addl $4,%ebp
jmp envloop
end:
  pushl $0
  call exit
</highlight>

<p>故事还没有结束，事实上，GCC也可以通过参数，指定不加载libc的startfiles，这样就和GAS编译效果一样了：</p>
<pre class="terminal">
<i style="color:gray"># hello.s 中仍然声明 .global _start</i>
$ gcc hello.s -o hello.bin -gstabs -nostartfiles
</pre>
<blockquote>
-nostartfiles
<p style="padding-left:2em;">Do not use the standard system startup files when linking. <br/>The standard system libraries are used normally,unless -nostdlib or -nodefaultlibs is used. </p>
</blockquote>

<h6>参考资料</h6>
<ul>
  <li><a href="http://linuxgazette.net/84/hawk.html" target="_blank">How main() is executed on Linux</a></li>
  <li><a href="http://asm.sourceforge.net/articles/startup.html#st" target="_blank">Startup state of a Linux/i386 ELF binary</a></li>
  <li><a href="http://www.win.tue.nl/~aeb/linux/hh/hh-14.html" target="_blank">Hackers Hut：ELF</a></li>
  <li><a href="http://articles.manugarg.com/aboutelfauxiliaryvectors.html" target="_blank">About ELF Auxiliary Vectors</a></li>
  <li>不使用libc，输出命令行参数及环境变量的汇编代码：<br /><a target="_blank" href="https://github.com/CJex/anthology/blob/master/asm/args.s">https://github.com/CJex/anthology/blob/master/asm/args.s</a></li>
</ul>
