---
title: Python FreeList内存重用机制一瞥
date: 2014-9-14
---

<p>一次被人问起为什么下面这段Python代码两次调用返回的List对象id相同：</p>
<div class="center">
<highlight python>
def foo(a=[]):
  return a

print id(foo([]))==id(foo([]))
</highlight></div>
<p>这很简单，只要认真读文档就会明白，因为<a href="https://docs.python.org/2/library/functions.html#id" target="_blank">Python中id方法</a>的返回值，只保证在该对象存活期内是唯一的，两个存活期不同的对象可能会有相同的id：</p>
<blockquote>
<h6>id(object)</h6>
<div style="padding-left:2em">Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. <b style="color:navy">Two objects with non-overlapping lifetimes may have the same id() value.</b>
</div>
<div style="padding-left:2em;"><b>CPython implementation detail: </b>This is the address of the object in memory.
</div>
</blockquote>
<p>比如<highlight python>print id([])==id([])</highlight>，其执行过程是先创建一个临时List #1，获取它的地址，然后List #1被Free，随后再创建新的List #2时，则有可能重用刚才被释放的List #1的内存，所以地址就有可能相同。</p>
<p>不过随后又有一个新问题，为什么<highlight python>id([])==id([])</highlight>始终为True？这也很简单，CPython中List、Tuple、Int等类型，内部实现其实都有一个<code>free_list</code>，当一个对象被销毁时，它的内存并不会被立即回收，而是放到这个池中，当下次再创建新的对象时，则重用上次被销毁对象的内存。从下面的代码可以推测出这个缓冲池的工作方式，按照对象创建销毁的先后次序不同，新的对象会领取到不同的地址：</p>
<div class="center">
<highlight python>
a=[]; b=[];
print id(a)==id(b)  # 这样肯定是 False 啦

def f1():
  a=[]
  return a

"""
执行一次 id(f1()) 大致过程为（假设free_list不为空）：
a=free_list.pop(); _tmp=id(a);
free_list.append(a); del a
每次都领到相同的free_list[-1]
所以始终为True
"""
print id(f1())==id(f1())

def f2():
  b=[]; a=[]
  return a

"""
执行 id(f2())的大致过程为
b=free_list.pop()
a=free_list.pop()
因为b在函数退出后即被销毁，所以先执行
free_list.append(b); del b;
_tmp=id(a)
free_list.append(a); del a;
因为 append与pop操作不对称，
所以始终为False
"""
print id(f2())==id(f2())

# 并且可以推断出下面的调用始终为True
i=id(f2()) ; f2();
print i==id(f2())
</highlight>
</div>

<p>可还有一个问题，为什么<highlight python>id(list())==id(list())</highlight>却为False呢？这还真没注意过，原来<code>list()</code>和ListLiteral内存分配的方法并不一样。先看看<code>free_list</code>实现在哪，见<a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c" target="_blank">listobject.c</a>：</p>
<div class="center">
<highlight c linenos=94 hl_lines=5>
/* Empty list reuse scheme to save calls to malloc and free */
#ifndef PyList_MAXFREELIST
#define PyList_MAXFREELIST 80
#endif
static PyListObject *free_list[PyList_MAXFREELIST];
static int numfree = 0;
</highlight>
</div>
<p>上面是<code>free_list</code>的声明，可见缓冲池的最大长度只有80，下面是创建List方法<code>PyList_New</code>：</p>
<div class="center">
<highlight c linenos=113 hl_lines=24,25,26>
PyObject *
PyList_New(Py_ssize_t size)
{
    PyListObject *op;
    size_t nbytes;
#ifdef SHOW_ALLOC_COUNT
    static int initialized = 0;
    if (!initialized) {
        Py_AtExit(show_alloc);
        initialized = 1;
    }
#endif

    if (size < 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
    printf("\nCall PyList_New\n");
    /* Check for overflow without an actual overflow,
     *  which can cause compiler to optimise out */
    if ((size_t)size > PY_SIZE_MAX / sizeof(PyObject *))
        return PyErr_NoMemory();
    nbytes = size * sizeof(PyObject *);
    if (numfree) { /*如果缓冲池中有可用元素*/
        numfree--;
        op = free_list[numfree]; /* free_list.pop() */
        _Py_NewReference((PyObject *)op);
#ifdef SHOW_ALLOC_COUNT
        count_reuse++;
#endif
    } else {/*free_list中没有可用元素则新建*/
        op = PyObject_GC_New(PyListObject, &PyList_Type);
        if (op == NULL)
            return NULL;
#ifdef SHOW_ALLOC_COUNT
        count_alloc++;
#endif
    }
    if (size <= 0)
        op->ob_item = NULL; /* Why? */
    else {
        op->ob_item = (PyObject **) PyMem_MALLOC(nbytes);
        if (op->ob_item == NULL) {
            Py_DECREF(op);
            return PyErr_NoMemory();
        }
        memset(op->ob_item, 0, nbytes);
    }
    Py_SIZE(op) = size;
    op->allocated = size;
    _PyObject_GC_TRACK(op);
    return (PyObject *) op;
}
</highlight>
</div>
<p>与之对应的则是List对象回收<code>list_dealloc</code>方法，需将对象放到<code>free_list</code>中以备后用：</p>


<div class="center">
<highlight c linenos=298 hl_lines=19>
static void
list_dealloc(PyListObject *op)
{
    Py_ssize_t i;
    PyObject_GC_UnTrack(op);
    Py_TRASHCAN_SAFE_BEGIN(op)
    if (op->ob_item != NULL) {
        /* Do it backwards, for Christian Tismer.
           There's a simple test case where somehow this reduces
           thrashing when a *very* large list is created and
           immediately deleted. */
        i = Py_SIZE(op);
        while (--i >= 0) {
            Py_XDECREF(op->ob_item[i]);
        }
        PyMem_FREE(op->ob_item);/*虽然Free了内容但未设置成NULL，不知为何*/
    }
    if (numfree < PyList_MAXFREELIST && PyList_CheckExact(op))
        free_list[numfree++] = op; /* free_list.append(op) */
    else
        Py_TYPE(op)->tp_free((PyObject *)op);
    Py_TRASHCAN_SAFE_END(op)
}
</highlight>
</div>

<p>这些就是<code>free_list</code>的实现源码，不单List类型，其它的Tuple、Set、Int等内建类型都有类似的实现。接着再看<code>list()</code>与<code>[]</code>两种形式Python解释器具体如何解释。直接看反编译得到的ByteCode：</p>

<table>
  <tr>
    <th>Python代码</th>
    <th>反编译输出</th>
  </tr>
  <tr>
    <td>
<highlight python>
import dis
def f():
  a=[]
  b=list()
dis.dis(f)
</highlight>
    </td>
    <td>
<pre>
 0 BUILD_LIST               0
 3 STORE_FAST               0 (a)

 6 LOAD_GLOBAL              0 (list)
 9 CALL_FUNCTION            0
12 STORE_FAST               1 (b)
15 LOAD_CONST               0 (None)
18 RETURN_VALUE
</pre>
    </td>
  </tr>
</table>
<p>也没什么奇怪的东西，一个是执行<code>BUILD_LIST</code>指令，一个是调用函数。再看看<code>BUILD_LIST</code>指令的具体是如何实现的，见<a href="http://svn.python.org/projects/python/trunk/Python/ceval.c" target="_blank">ceval.c</a>，可以看到它直接调用了<code>PyList_New</code>函数，所以它会用到<code>free_list</code>：</p>
<div class="center">
<highlight python linenos=2202 hl_lines=2>
case BUILD_LIST:
  x =  PyList_New(oparg);
  if (x != NULL) {
    for (; --oparg >= 0;) {
      w = POP();
      PyList_SET_ITEM(x, oparg, w);
    }
    PUSH(x);
    continue;
  }
  break;
</highlight>
</div>
<p>而<code>list()</code>则是直接调用类型构造方法，对应于<a href="http://svn.python.org/projects/python/trunk/Objects/listobject.c" target="_blank">listobject.c</a>中<code>PyList_Type</code>结构：</p>


<div class="center">
<highlight c linenos=2767 hl_lines=6,10>
PyTypeObject PyList_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "list",
    sizeof(PyListObject),
    0,
    (destructor)list_dealloc,                   /* tp_dealloc */
    /*  ............  */
    (initproc)list_init,                        /* tp_init */
    PyType_GenericAlloc,                        /* tp_alloc */
    PyType_GenericNew,                          /* tp_new */
    PyObject_GC_Del,                            /* tp_free */
};
</highlight>
</div>
<p>其中<code>tp_new</code>字段就是该类型的New方法，可以看到List类型只用了<code>PyType_GenericNew</code>函数，该方法并不会使用<code>free_list</code>，但是List类型的析构方法依然是<code>list_dealloc</code>，所以<highlight python>id(list())==id([])</highlight>仍然为True。为什么List类型默认的New方法不使用缓冲池呢？我也不太明白。也许是因为按照标准文档中指示的原则，Mutable类型的<a href="https://docs.python.org/2/c-api/typeobj.html#c.PyTypeObject.tp_new" target="_blank">tp_new</a>方法不应作过多的初始化操作：</p>
<blockquote>
<h6><a href="https://docs.python.org/2/c-api/typeobj.html#c.PyTypeObject.tp_new" target="_blank">PyTypeObject.tp_new</a></h6>
A good rule of thumb is that for immutable types, all initialization should take place in tp_new, while for mutable types, most initialization should be deferred to tp_init.
</blockquote>
<p>类似的dict类型也是如此，而int、set、tuple这些Immutable类型则两种创建方式都会使用<code>free_list</code>。</p>


